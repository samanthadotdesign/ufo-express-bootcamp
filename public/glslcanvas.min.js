!(function (e, t) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = t() : typeof define === 'function' && define.amd ? define(t) : e.GlslCanvas = t(); }(this, () => {
  const e = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}; const t = typeof window !== 'undefined' ? window : void 0 !== e ? e : typeof self !== 'undefined' ? self : {}; const r = function (e) { const t = i.call(e); return t === '[object Function]' || typeof e === 'function' && t !== '[object RegExp]' || typeof window !== 'undefined' && (e === window.setTimeout || e === window.alert || e === window.confirm || e === window.prompt); }; var i = Object.prototype.toString; let n; const a = ((function (e, t) { (t = e.exports = function (e) { return e.replace(/^\s*|\s*$/g, ''); }).left = function (e) { return e.replace(/^\s*/, ''); }, t.right = function (e) { return e.replace(/\s*$/, ''); }; }(n = { exports: {} }, n.exports)), n.exports); const s = function (e, t, i) { if (!r(t)) throw new TypeError('iterator must be a function'); arguments.length < 3 && (i = this); o.call(e) === '[object Array]' ? (function (e, t, r) { for (let i = 0, n = e.length; i < n; i++)u.call(e, i) && t.call(r, e[i], i, e); }(e, t, i)) : typeof e === 'string' ? (function (e, t, r) { for (let i = 0, n = e.length; i < n; i++)t.call(r, e.charAt(i), i, e); }(e, t, i)) : (function (e, t, r) { for (const i in e)u.call(e, i) && t.call(r, e[i], i, e); }(e, t, i)); }; var o = Object.prototype.toString; var u = Object.prototype.hasOwnProperty; const h = function (e) { if (!e) return {}; const t = {}; return s(a(e).split('\n'), (e) => { let r; const i = e.indexOf(':'); const n = a(e.slice(0, i)).toLowerCase(); const s = a(e.slice(i + 1)); void 0 === t[n] ? t[n] = s : (r = t[n], Object.prototype.toString.call(r) === '[object Array]' ? t[n].push(s) : t[n] = [t[n], s]); }), t; }; const l = function () { for (var e = {}, t = 0; t < arguments.length; t++) { const r = arguments[t]; for (const i in r)f.call(r, i) && (e[i] = r[i]); } return e; }; var f = Object.prototype.hasOwnProperty; const d = v; const c = v; function g(e, t, i) { let n = e; return r(t) ? (i = t, typeof e === 'string' && (n = { uri: e })) : n = l(t, { uri: e }), n.callback = i, n; } function v(e, t, r) { return m(t = g(e, t, r)); } function m(e) { if (void 0 === e.callback) throw new Error('callback argument missing'); let t = !1; const r = function (r, i, n) { t || (t = !0, e.callback(r, i, n)); }; function i(e) { return clearTimeout(u), e instanceof Error || (e = new Error(`${e || 'Unknown XMLHttpRequest Error'}`)), e.statusCode = 0, r(e, E); } function n() { if (!s) { let t; clearTimeout(u), t = e.useXDR && void 0 === o.status ? 200 : o.status === 1223 ? 204 : o.status; let i = E; let n = null; return t !== 0 ? (i = {
    body: (function () { let e = void 0; if (e = o.response ? o.response : o.responseText || (function (e) { try { if (e.responseType === 'document') return e.responseXML; const t = e.responseXML && e.responseXML.documentElement.nodeName === 'parsererror'; if (e.responseType === '' && !t) return e.responseXML; } catch (e) {} return null; }(o)), m) try { e = JSON.parse(e); } catch (e) {} return e; }()), statusCode: t, method: f, headers: {}, url: l, rawRequest: o,
  }, o.getAllResponseHeaders && (i.headers = h(o.getAllResponseHeaders()))) : n = new Error('Internal XMLHttpRequest Error'), r(n, i, i.body); } } let a; let s; var o = e.xhr || null; o || (o = e.cors || e.useXDR ? new v.XDomainRequest() : new v.XMLHttpRequest()); let u; var l = o.url = e.uri || e.url; var f = o.method = e.method || 'GET'; let d = e.body || e.data; const c = o.headers = e.headers || {}; const g = !!e.sync; var m = !1; var E = {
    body: void 0, headers: {}, statusCode: 0, method: f, url: l, rawRequest: o,
  }; if ('json' in e && !1 !== e.json && (m = !0, c.accept || c.Accept || (c.Accept = 'application/json'), f !== 'GET' && f !== 'HEAD' && (c['content-type'] || c['Content-Type'] || (c['Content-Type'] = 'application/json'), d = JSON.stringify(!0 === e.json ? d : e.json))), o.onreadystatechange = function () { o.readyState === 4 && setTimeout(n, 0); }, o.onload = n, o.onerror = i, o.onprogress = function () {}, o.onabort = function () { s = !0; }, o.ontimeout = i, o.open(f, l, !g, e.username, e.password), g || (o.withCredentials = !!e.withCredentials), !g && e.timeout > 0 && (u = setTimeout(() => { if (!s) { s = !0, o.abort('timeout'); const e = new Error('XMLHttpRequest timeout'); e.code = 'ETIMEDOUT', i(e); } }, e.timeout)), o.setRequestHeader) for (a in c)c.hasOwnProperty(a) && o.setRequestHeader(a, c[a]); else if (e.headers && !(function (e) { for (const t in e) if (e.hasOwnProperty(t)) return !1; return !0; }(e.headers))) throw new Error('Headers cannot be set on an XDomainRequest object'); return 'responseType' in e && (o.responseType = e.responseType), 'beforeSend' in e && typeof e.beforeSend === 'function' && e.beforeSend(o), o.send(d || null), o; }v.XMLHttpRequest = t.XMLHttpRequest || function () {}, v.XDomainRequest = 'withCredentials' in new v.XMLHttpRequest() ? v.XMLHttpRequest : t.XDomainRequest, (function (e, t) { for (let r = 0; r < e.length; r++)t(e[r]); }(['get', 'put', 'post', 'patch', 'head', 'delete'], (e) => { v[e === 'delete' ? 'del' : e] = function (t, r, i) { return (r = g(t, r, i)).method = e.toUpperCase(), m(r); }; })), d.default = c; const E = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (e) { return typeof e; } : function (e) { return e && typeof Symbol === 'function' && e.constructor === Symbol && e !== Symbol.prototype ? 'symbol' : typeof e; }; const T = ((function () { function e(e) { this.value = e; } function t(t) { let r; let i; function n(r, i) { try { const s = t[r](i); const o = s.value; o instanceof e ? Promise.resolve(o.value).then((e) => { n('next', e); }, (e) => { n('throw', e); }) : a(s.done ? 'return' : 'normal', s.value); } catch (e) { a('throw', e); } } function a(e, t) { switch (e) { case 'return': r.resolve({ value: t, done: !0 }); break; case 'throw': r.reject(t); break; default: r.resolve({ value: t, done: !1 }); }(r = r.next) ? n(r.key, r.arg) : i = null; } this._invoke = function (e, t) { return new Promise((a, s) => { const o = {
    key: e, arg: t, resolve: a, reject: s, next: null,
  }; i ? i = i.next = o : (r = i = o, n(e, t)); }); }, typeof t.return !== 'function' && (this.return = void 0); } typeof Symbol === 'function' && Symbol.asyncIterator && (t.prototype[Symbol.asyncIterator] = function () { return this; }), t.prototype.next = function (e) { return this._invoke('next', e); }, t.prototype.throw = function (e) { return this._invoke('throw', e); }, t.prototype.return = function (e) { return this._invoke('return', e); }; }()), function (e, t) { if (!(e instanceof t)) throw new TypeError('Cannot call a class as a function'); }); const p = (function () { function e(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } return function (t, r, i) { return r && e(t.prototype, r), i && e(t, i), t; }; }()); const y = function (e) { if (Array.isArray(e)) { for (var t = 0, r = Array(e.length); t < e.length; t++)r[t] = e[t]; return r; } return Array.from(e); }; let R = ''; const _ = '\n\tThis page requires a browser that supports WebGL.<br/>\n\t<a href="http://get.webgl.org">Click here to upgrade your browser.</a>\n'; const b = '\n\tIt does not appear your computer can support WebGL.<br/>\n\t<a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>\n'; const x = 1; const A = 2; function w(e, t, r) { function i(t, i) { let n; let a; typeof r === 'function' ? r(t) : (n = i, (a = e.parentNode) && (a.innerHTML = `\n<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>\n<td align="center">\n<div style="display: table-cell; vertical-align: middle;">\n<div style="">${n}</div>\n</div>\n</td></tr></table>\n`)); } if (!window.WebGLRenderingContext) return i(x, _), null; const n = (function (e, t) { for (var r = ['webgl', 'experimental-webgl'], i = null, n = 0; n < r.length; ++n) try { i = e.getContext(r[n], t); } catch (e) { if (i) break; } return i; }(e, t)); return n ? n.getExtension('OES_standard_derivatives') : i(A, b), n; } function S(e, t, r, i) { const n = e.gl; const a = n.createShader(r); return n.shaderSource(a, t), n.compileShader(a), n.getShaderParameter(a, n.COMPILE_STATUS) ? a : (R = n.getShaderInfoLog(a), console.error(`*** Error compiling shader ${a}:${R}`), e.trigger('error', {
    shader: a, source: t, type: r, error: R, offset: i || 0,
  }), n.deleteShader(a), null); } function U(e, t, r, i) { for (var n = e.gl, a = n.createProgram(), s = 0; s < t.length; ++s)n.attachShader(a, t[s]); if (r) for (let o = 0; o < r.length; ++o)n.bindAttribLocation(a, i ? i[o] : o, r[o]); return n.linkProgram(a), n.getProgramParameter(a, n.LINK_STATUS) ? a : (R = n.getProgramInfoLog(a), console.log(`Error in program linking:${R}`), n.deleteProgram(a), null); } function P(e) { return (e & e - 1) == 0; } function L(e) { const t = new Set(); return Object.assign(e, {
    on(e, r) { const i = {}; i[e] = r, t.add(i); }, off(e, r) { if (r) { const i = {}; i[e] = r, t.delete(i); } else { let n = !0; let a = !1; let s = void 0; try { for (var o, u = t[Symbol.iterator](); !(n = (o = u.next()).done); n = !0) { const h = o.value; let l = !0; let f = !1; let d = void 0; try { for (var c, g = Object.keys(h)[Symbol.iterator](); !(l = (c = g.next()).done); l = !0) { if (c.value === e) return void t.delete(h); } } catch (e) { f = !0, d = e; } finally { try { !l && g.return && g.return(); } finally { if (f) throw d; } } } } catch (e) { a = !0, s = e; } finally { try { !n && u.return && u.return(); } finally { if (a) throw s; } } } }, listSubscriptions() { let e = !0; let r = !1; let i = void 0; try { for (var n, a = t[Symbol.iterator](); !(e = (n = a.next()).done); e = !0) { const s = n.value; console.log(s); } } catch (e) { r = !0, i = e; } finally { try { !e && a.return && a.return(); } finally { if (r) throw i; } } }, subscribe(e) { t.add(e); }, unsubscribe(e) { t.delete(e); }, unsubscribeAll() { t.clear(); }, trigger(e) { for (var r = arguments.length, i = Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)i[n - 1] = arguments[n]; let a = !0; let s = !1; let o = void 0; try { for (var u, h = t[Symbol.iterator](); !(a = (u = h.next()).done); a = !0) { const l = u.value; typeof l[e] === 'function' && l[e].apply(l, y(i)); } } catch (e) { s = !0, o = e; } finally { try { !a && h.return && h.return(); } finally { if (s) throw o; } } },
  }); } const X = (function () { function e(t, r) { const i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}; T(this, e), L(this), this.gl = t, this.texture = t.createTexture(), this.texture && (this.valid = !0), this.bind(), this.name = r, this.source = null, this.sourceType = null, this.loading = null, this.setData(1, 1, new Uint8Array([0, 0, 0, 255]), { filtering: 'linear' }), this.setFiltering(i.filtering), this.load(i); } return p(e, [{ key: 'destroy', value() { this.valid && (this.gl.deleteTexture(this.texture), this.texture = null, delete this.data, this.data = null, this.valid = !1); } }, { key: 'bind', value(t) { this.valid && (typeof t === 'number' && e.activeUnit !== t && (this.gl.activeTexture(this.gl.TEXTURE0 + t), e.activeUnit = t), e.activeTexture !== this.texture && (this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture), e.activeTexture = this.texture)); } }, { key: 'load', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.loading = null, typeof e.url === 'string' ? void 0 !== this.url && e.url === this.url || this.setUrl(e.url, e) : e.element ? this.setElement(e.element, e) : e.data && e.width && e.height && this.setData(e.width, e.height, e.data, e); } }, { key: 'setUrl', value(e) { const t = this; const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; if (this.valid) return this.url = e, this.source = this.url, this.sourceType = 'url', this.loading = new Promise((i, n) => { const a = e.split('.').pop().toLowerCase(); const s = a === 'ogv' || a === 'webm' || a === 'mp4'; let o = void 0; s ? ((o = document.createElement('video')).autoplay = !0, r.filtering = 'nearest') : o = new Image(), o.onload = function () { try { t.setElement(o, r); } catch (e) { console.log(`Texture '${t.name}': failed to load url: '${t.source}'`, e, r); }i(t); }, o.onerror = function (e) { console.log(`Texture '${t.name}': failed to load url: '${t.source}'`, e, r), i(t); }, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) && t.source.slice(0, 5) === 'data:' || (o.crossOrigin = 'anonymous'), o.src = t.source, s && t.setElement(o, r); }), this.loading; } }, { key: 'setData', value(e, t, r) { const i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}; return this.width = e, this.height = t, this.source = r, this.sourceType = 'data', this.update(i), this.setFiltering(i), this.loading = Promise.resolve(this), this.loading; } }, { key: 'setElement', value(e, t) { const r = this; const i = e; if (typeof e === 'string' && (e = document.querySelector(e)), e instanceof HTMLCanvasElement || e instanceof HTMLImageElement || e instanceof HTMLVideoElement) this.source = e, this.sourceType = 'element', e instanceof HTMLVideoElement ? (e.addEventListener('canplaythrough', () => { r.intervalID = setInterval(() => { r.update(t); }, 15); }, !0), e.addEventListener('ended', () => { e.currentTime = 0, e.play(); }, !0)) : this.update(t), this.setFiltering(t); else { let n = `the 'element' parameter (\`element: ${JSON.stringify(i)}\`) must be a CSS `; n += 'selector string, or a <canvas>, <image> or <video> object', console.log(`Texture '${this.name}': ${n}`, t); } return this.loading = Promise.resolve(this), this.loading; } }, { key: 'update', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; this.valid && (this.bind(), this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1 !== e.UNPACK_FLIP_Y_WEBGL), this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.UNPACK_PREMULTIPLY_ALPHA_WEBGL || !1), this.sourceType === 'element' && (this.source instanceof HTMLCanvasElement || this.source instanceof HTMLVideoElement || this.source instanceof HTMLImageElement && this.source.complete) ? (this.source instanceof HTMLVideoElement ? (this.width = this.source.videoWidth, this.height = this.source.videoHeight) : (this.width = this.source.width, this.height = this.source.height), this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.source)) : this.sourceType === 'data' && this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.width, this.height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, this.source), this.trigger('loaded', this)); } }, { key: 'setFiltering', value() { const e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; if (this.valid) { this.powerOf2 = P(this.width) && P(this.height); const t = this.powerOf2 ? 'mipmap' : 'linear'; this.filtering = e.filtering || t; const r = this.gl; this.bind(), this.powerOf2 ? (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, e.TEXTURE_WRAP_S || e.repeat && r.REPEAT || r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, e.TEXTURE_WRAP_T || e.repeat && r.REPEAT || r.CLAMP_TO_EDGE), this.filtering === 'mipmap' ? (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR_MIPMAP_LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR), r.generateMipmap(r.TEXTURE_2D)) : this.filtering === 'linear' ? (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR)) : this.filtering === 'nearest' && (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST))) : (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), this.filtering === 'mipmap' && (this.filtering = 'linear'), this.filtering === 'nearest' ? (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.NEAREST)) : (r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_2D, r.TEXTURE_MAG_FILTER, r.LINEAR))); } } }]), e; }()); X.getMaxTextureSize = function (e) { return e.getParameter(e.MAX_TEXTURE_SIZE); }, X.activeUnit = -1; const F = (function () { function e(t, r, i) { const n = this; T(this, e), L(this), r = r || {}, i = i || {}, !t.hasAttribute('data-fullscreen') || t.getAttribute('data-fullscreen') != '1' && t.getAttribute('data-fullscreen') != 'true' ? (this.width = t.clientWidth, this.height = t.clientHeight) : (this.width = window.innerWidth, this.height = window.innerHeight, t.width = window.innerWidth, t.height = window.innerHeight), this.canvas = t, this.gl = void 0, this.program = void 0, this.textures = {}, this.buffers = {}, this.uniforms = {}, this.vbo = {}, this.isValid = !1, this.animationFrameRequest = void 0, this.BUFFER_COUNT = 0, this.vertexString = r.vertexString || '\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nattribute vec2 a_position;\nattribute vec2 a_texcoord;\n\nvarying vec2 v_texcoord;\n\nvoid main() {\n    gl_Position = vec4(a_position, 0.0, 1.0);\n    v_texcoord = a_texcoord;\n}\n', this.fragmentString = r.fragmentString || '\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvarying vec2 v_texcoord;\n\nvoid main(){\n    gl_FragColor = vec4(0.0);\n}\n'; const a = w(t, r, i.onError); if (a) { if (this.gl = a, this.timeLoad = this.timePrev = performance.now(), this.timeDelta = 0, this.forceRender = !0, this.paused = !1, this.realToCSSPixels = window.devicePixelRatio || 1, t.style.backgroundColor = r.backgroundColor || 'rgba(1,1,1,0)', t.hasAttribute('data-fragment')) this.fragmentString = t.getAttribute('data-fragment'); else if (t.hasAttribute('data-fragment-url')) { const s = t.getAttribute('data-fragment-url'); d.get(s, (e, t, r) => { n.load(r, n.vertexString); }); } if (t.hasAttribute('data-vertex')) this.vertexString = t.getAttribute('data-vertex'); else if (t.hasAttribute('data-vertex-url')) { const o = t.getAttribute('data-vertex-url'); d.get(o, (e, t, r) => { n.load(n.fragmentString, r); }); } if (this.load(), this.program) { const u = a.getAttribLocation(this.program, 'a_texcoord'); this.vbo.texCoords = a.createBuffer(), this.gl.bindBuffer(a.ARRAY_BUFFER, this.vbo.texCoords), this.gl.bufferData(a.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]), a.STATIC_DRAW), this.gl.enableVertexAttribArray(u), this.gl.vertexAttribPointer(u, 2, a.FLOAT, !1, 0, 0); const h = a.getAttribLocation(this.program, 'a_position'); if (this.vbo.vertices = a.createBuffer(), this.gl.bindBuffer(a.ARRAY_BUFFER, this.vbo.vertices), this.gl.bufferData(a.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1]), a.STATIC_DRAW), this.gl.enableVertexAttribArray(h), this.gl.vertexAttribPointer(h, 2, a.FLOAT, !1, 0, 0), t.hasAttribute('data-textures')) { const l = t.getAttribute('data-textures').split(','); for (const f in l) this.setUniform(`u_tex${f}`, l[f]); } const c = { x: 0, y: 0 }; document.addEventListener('mousemove', (e) => { c.x = e.clientX || e.pageX, c.y = e.clientY || e.pageY; }, !1); const g = this; return this.setMouse({ x: 0, y: 0 }), (function e() { g.nMouse > 1 && g.setMouse(c), g.resize() && (g.forceRender = !0), g.render(), g.animationFrameRequest = window.requestAnimationFrame(e); }()), this; } } } return p(e, [{ key: 'destroy', value() { for (const e in cancelAnimationFrame(this.animationFrameRequest), this.animated = !1, this.isValid = !1, this.textures)e.destroy && e.destroy(); for (const t in this.textures = {}, this.attribs) this.gl.deleteBuffer(this.attribs[t]); for (const r in this.gl.useProgram(null), this.gl.deleteProgram(this.program), this.buffers) { const i = this.buffers[r]; this.gl.deleteProgram(i.program); } this.program = null, this.gl = null; } }, { key: 'load', value(e, t) { if (t && (this.vertexString = t), e && (this.fragmentString = e), this.animated = !1, this.nDelta = (this.fragmentString.match(/u_delta/g) || []).length, this.nTime = (this.fragmentString.match(/u_time/g) || []).length, this.nDate = (this.fragmentString.match(/u_date/g) || []).length, this.nMouse = (this.fragmentString.match(/u_mouse/g) || []).length, this.animated = this.nDate > 1 || this.nTime > 1 || this.nMouse > 1, this.fragmentString.search(/sampler2D/g)) for (let r = this.fragmentString.split('\n'), i = 0; i < r.length; i++) { const n = r[i].match(/uniform\s*sampler2D\s*([\w]*);\s*\/\/\s*([\w|\:\/\/|\.|\-|\_]*)/i); if (n) { const a = n[2].split('.').pop().toLowerCase(); n[1] && n[2] && (a === 'jpg' || a === 'jpeg' || a === 'png' || a === 'ogv' || a === 'webm' || a === 'mp4') && this.setUniform(n[1], n[2]); } if (r[i].match(/\s*void\s*main\s*/g)) break; } const s = S(this, this.vertexString, this.gl.VERTEX_SHADER); let o = S(this, this.fragmentString, this.gl.FRAGMENT_SHADER); o ? this.isValid = !0 : (o = S(this, 'void main(){\n\tgl_FragColor = vec4(1.0);\n}', this.gl.FRAGMENT_SHADER), this.isValid = !1); const u = U(this, [s, o]); this.gl.useProgram(u), this.gl.deleteShader(s), this.gl.deleteShader(o), this.program = u, this.change = !0, this.BUFFER_COUNT = 0; const h = this.getBuffers(this.fragmentString); Object.keys(h).length && this.loadPrograms(h), this.buffers = h, this.texureIndex = this.BUFFER_COUNT, this.trigger('load', {}), this.forceRender = !0, this.render(); } }, {
    key: 'test',
    value(e, t, r) { const i = this.vertexString; const n = this.fragmentString; const a = this.paused; const s = this.gl.getExtension('EXT_disjoint_timer_query'); const o = s.createQueryEXT(); let u = this.isValid; (t || r) && (this.load(t, r), u = this.isValid, this.forceRender = !0, this.render()), this.paused = !0, s.beginQueryEXT(s.TIME_ELAPSED_EXT, o), this.forceRender = !0, this.render(), s.endQueryEXT(s.TIME_ELAPSED_EXT); const h = this; !(function l() { h.forceRender = !0, h.render(); const f = s.getQueryObjectEXT(o, s.QUERY_RESULT_AVAILABLE_EXT); const d = h.gl.getParameter(s.GPU_DISJOINT_EXT); if (f && !d) { const c = {
      wasValid: u, frag: t || h.fragmentString, vert: r || h.vertexString, timeElapsedMs: s.getQueryObjectEXT(o, s.QUERY_RESULT_EXT) / 1e6,
    }; h.paused = a, (t || r) && h.load(n, i), e(c); } else window.requestAnimationFrame(l); }()); },
  }, { key: 'loadTexture', value(e, t, r) { const i = this; r || (r = {}), typeof t === 'string' ? r.url = t : (void 0 === t ? 'undefined' : E(t)) === 'object' && t.data && t.width && t.height ? (r.data = t.data, r.width = t.width, r.height = t.height) : (void 0 === t ? 'undefined' : E(t)) === 'object' && (r.element = t), this.textures[e] ? this.textures[e] && (this.textures[e].load(r), this.textures[e].on('loaded', (e) => { i.forceRender = !0; })) : (this.textures[e] = new X(this.gl, e, r), this.textures[e].on('loaded', (e) => { i.forceRender = !0; })); } }, { key: 'refreshUniforms', value() { this.uniforms = {}; } }, { key: 'setUniform', value(e) { for (var t = {}, r = arguments.length, i = Array(r > 1 ? r - 1 : 0), n = 1; n < r; n++)i[n - 1] = arguments[n]; t[e] = i, this.setUniforms(t); } }, {
    key: 'setUniforms',
    value(e) { const t = (function e(t) { const r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; const i = []; for (let n in t) { const a = t[n]; let s = void 0; if (r && (n = `${r}.${n}`), typeof a === 'number') { i.push({
      type: 'float', method: '1f', name: n, value: a,
    }); } else if (Array.isArray(a)) { if (typeof a[0] === 'number') { a.length === 1 ? i.push({
      type: 'float', method: '1f', name: n, value: a,
    }) : a.length >= 2 && a.length <= 4 ? i.push({
      type: `vec${a.length}`, method: `${a.length}fv`, name: n, value: a,
    }) : a.length > 4 && i.push({
      type: 'float[]', method: '1fv', name: `${n}[0]`, value: a,
    }); } else if (typeof a[0] === 'string') { i.push({
      type: 'sampler2D', method: '1i', name: n, value: a,
    }); } else if (Array.isArray(a[0]) && typeof a[0][0] === 'number') { if (a[0].length >= 2 && a[0].length <= 4) { for (s = 0; s < a.length; s++) { i.push({
      type: `vec${ a[0].length}`, method: `${a[s].length}fv`, name: `${n}[${s}]`, value: a[s],
    }); } } } else if (E(a[0]) === 'object') for (s = 0; s < a.length; s++)i.push.apply(i, y(e(a[s], `${n}[${s}]`))); } else { typeof a === 'boolean' ? i.push({
      type: 'bool', method: '1i', name: n, value: a,
    }) : typeof a === 'string' ? i.push({
      type: 'sampler2D', method: '1i', name: n, value: a,
    }) : (void 0 === a ? 'undefined' : E(a)) === 'object' && i.push.apply(i, y(e(a, n))); } } return i; }(e)); for (const r in t)t[r].type === 'sampler2D' ? this.loadTexture(t[r].name, t[r].value[0]) : this.uniform(t[r].method, t[r].type, t[r].name, t[r].value); this.forceRender = !0; },
  }, { key: 'setMouse', value(e) { const t = this.canvas.getBoundingClientRect(); if (e && e.x && e.x >= t.left && e.x <= t.right && e.y && e.y >= t.top && e.y <= t.bottom) { const r = (e.x - t.left) * this.realToCSSPixels; const i = this.canvas.height - (e.y - t.top) * this.realToCSSPixels; this.uniform('2f', 'vec2', 'u_mouse', r, i); } } }, { key: 'uniform', value(e, t, r) { this.uniforms[r] = this.uniforms[r] || {}; for (var i = this.uniforms[r], n = arguments.length, a = Array(n > 3 ? n - 3 : 0), s = 3; s < n; s++)a[s - 3] = arguments[s]; let o; let u; if ((o = i.value, u = a, !(!o || !u) && o.toString() !== u.toString()) || this.change || !i.location || !i.value) for (const h in i.name = r, i.type = t, i.value = a, i.method = `uniform${e}`, this.gl.useProgram(this.program), i.location = this.gl.getUniformLocation(this.program, r), this.gl[i.method].apply(this.gl, [i.location].concat(i.value)), this.buffers) { const l = this.buffers[h]; this.gl.useProgram(l.program); const f = this.gl.getUniformLocation(l.program, r); this.gl[i.method].apply(this.gl, [f].concat(i.value)); } } }, { key: 'uniformTexture', value(e, t, r) { if (void 0 === this.textures[e]) this.loadTexture(e, t, r); else { for (const i in this.uniform('1i', 'sampler2D', e, this.texureIndex), this.buffers) { const n = this.buffers[i]; this.gl.useProgram(n.program), this.gl.activeTexture(this.gl.TEXTURE0 + this.texureIndex), this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[e].texture); } this.gl.useProgram(this.program), this.gl.activeTexture(this.gl.TEXTURE0 + this.texureIndex), this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures[e].texture), this.uniform('2f', 'vec2', `${e}Resolution`, this.textures[e].width, this.textures[e].height); } } }, { key: 'resize', value() { if (this.width !== this.canvas.clientWidth || this.height !== this.canvas.clientHeight) { this.realToCSSPixels = window.devicePixelRatio || 1; const e = Math.floor(this.gl.canvas.clientWidth * this.realToCSSPixels); const t = Math.floor(this.gl.canvas.clientHeight * this.realToCSSPixels); return this.gl.canvas.width === e && this.gl.canvas.height === t || (this.gl.canvas.width = e, this.gl.canvas.height = t, this.gl.viewport(0, 0, this.gl.canvas.width, this.gl.canvas.height)), this.width = this.canvas.clientWidth, this.height = this.canvas.clientHeight, this.resizeSwappableBuffers(), !0; } return !1; } }, {
    key: 'render',
    value() { let e; if (this.visible = (e = this.canvas).getBoundingClientRect().top + e.height > 0 && e.getBoundingClientRect().top < (window.innerHeight || document.documentElement.clientHeight), this.forceRender || this.change || this.animated && this.visible && !this.paused) { const t = new Date(); const
      r = performance.now(); for (const i in this.timeDelta = (r - this.timePrev) / 1e3, this.timePrev = r, this.nDelta > 1 && this.uniform('1f', 'float', 'u_delta', this.timeDelta), this.nTime > 1 && this.uniform('1f', 'float', 'u_time', (r - this.timeLoad) / 1e3), this.nDate && this.uniform('4f', 'float', 'u_date', t.getFullYear(), t.getMonth(), t.getDate(), 3600 * t.getHours() + 60 * t.getMinutes() + t.getSeconds() + 0.001 * t.getMilliseconds()), this.uniform('2f', 'vec2', 'u_resolution', this.canvas.width, this.canvas.height), this.buffers) { const n = this.buffers[i]; this.uniform('1i', 'sampler2D', n.name, n.bundle.input.index); } for (const a in this.texureIndex = this.BUFFER_COUNT, this.textures) this.uniformTexture(a), this.texureIndex++; this.renderPrograms(), this.trigger('render', {}), this.change = !1, this.forceRender = !1; } },
  }, { key: 'pause', value() { this.paused = !0; } }, { key: 'play', value() { this.paused = !1; } }, { key: 'renderPrograms', value() { const e = this.gl; const t = e.canvas.width; const r = e.canvas.height; for (const i in e.viewport(0, 0, t, r), this.buffers) { const n = this.buffers[i]; n.bundle.render(t, r, n.program, n.name), e.bindFramebuffer(e.FRAMEBUFFER, null); }e.useProgram(this.program), e.drawArrays(e.TRIANGLES, 0, 6); } }, { key: 'getBuffers', value(e) { const t = {}; return e && e.replace(/(?:^\s*)((?:#if|#elif)(?:\s*)(defined\s*\(\s*BUFFER_)(\d+)(?:\s*\))|(?:#ifdef)(?:\s*BUFFER_)(\d+)(?:\s*))/gm, function () { const r = arguments[3] || arguments[4]; t[`u_buffer${r}`] = { fragment: `#define BUFFER_${r}\n${e}` }; }), t; } }, { key: 'loadPrograms', value(e) { const t = this.gl; const r = S(this, this.vertexString, t.VERTEX_SHADER); for (const i in e) { const n = e[i]; let a = S(this, n.fragment, t.FRAGMENT_SHADER, 1); a ? this.isValid = !0 : (a = S(this, 'void main(){\n\tgl_FragColor = vec4(1.0);\n}', t.FRAGMENT_SHADER), this.isValid = !1); const s = U(this, [r, a]); n.name = i, n.program = s, n.bundle = this.createSwappableBuffer(this.canvas.width, this.canvas.height, s), t.deleteShader(a); }t.deleteShader(r); } }, {
    key: 'createSwappableBuffer',
    value(e, t, r) { let i = this.createBuffer(e, t, r); let n = this.createBuffer(e, t, r); const a = this.gl; return {
      input: i, output: n, swap() { const e = i; i = n, n = e, this.input = i, this.output = n; }, render(e, t, r, i) { a.useProgram(r), a.viewport(0, 0, e, t), a.bindFramebuffer(a.FRAMEBUFFER, this.input.buffer), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, this.output.texture, 0), a.drawArrays(a.TRIANGLES, 0, 6), this.swap(); }, resize(e, t, r, i) { a.useProgram(r), a.viewport(0, 0, e, t), this.input.resize(e, t), this.output.resize(e, t); },
    }; },
  }, {
    key: 'createBuffer',
    value(e, t, r) { const i = this.gl; let n = this.BUFFER_COUNT; this.BUFFER_COUNT += 2, i.getExtension('OES_texture_float'); let a = i.createTexture(); i.activeTexture(i.TEXTURE0 + n), i.bindTexture(i.TEXTURE_2D, a), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, e, t, 0, i.RGBA, i.FLOAT, null), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE); let s = i.createFramebuffer(); return {
      index: n, texture: a, buffer: s, W: e, H: t, resize(e, t) { i.bindFramebuffer(i.FRAMEBUFFER, s); const r = Math.min(e, this.W); const o = Math.min(t, this.H); const u = new Float32Array(r * o * 4); i.readPixels(0, 0, r, o, i.RGBA, i.FLOAT, u), i.bindFramebuffer(i.FRAMEBUFFER, null); const h = n + 1; const l = i.createTexture(); i.activeTexture(i.TEXTURE0 + h), i.bindTexture(i.TEXTURE_2D, l), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, e, t, 0, i.RGBA, i.FLOAT, null), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE), i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, r, o, i.RGBA, i.FLOAT, u); const f = i.createFramebuffer(); i.bindFramebuffer(i.FRAMEBUFFER, null), i.deleteTexture(a), i.activeTexture(i.TEXTURE0 + n), i.bindTexture(i.TEXTURE_2D, l), n = this.index = n, a = this.texture = l, s = this.buffer = f, this.W = e, this.H = t; },
    }; },
  }, { key: 'resizeSwappableBuffers', value() { const e = this.gl; const t = e.canvas.width; const r = e.canvas.height; for (const i in e.viewport(0, 0, t, r), this.buffers) { const n = this.buffers[i]; n.bundle.resize(t, r, n.program, n.name); }e.useProgram(this.program); } }, { key: 'version', value() { return '0.1.7'; } }]), e; }()); return window.addEventListener('load', () => { !(function () { const e = document.getElementsByClassName('glslCanvas'); if (e.length > 0) { window.glslCanvases = []; for (let t = 0; t < e.length; t++) { const r = new F(e[t]); r.isValid && window.glslCanvases.push(r); } } }()); }), F; }));
// # sourceMappingURL=GlslCanvas.min.js.map
